
---------------------------------------------------------------start sequencer
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity sequencer is
    Port (
        clk    : in  STD_LOGIC;
        reset  : in  STD_LOGIC;
        opcode : in  STD_LOGIC_VECTOR(3 downto 0);
        acc_Z  : in  STD_LOGIC;
        acc_15 : in  STD_LOGIC;
        selA   : out STD_LOGIC;
        selB   : out STD_LOGIC;
        RnW    : out STD_LOGIC;
        pc_ld  : out STD_LOGIC;
        ir_ld  : out STD_LOGIC;
        acc_ld : out STD_LOGIC;
        acc_oe : out STD_LOGIC;
        alufs  : out STD_LOGIC_VECTOR(1 downto 0)
    );
end sequencer ;

architecture Behavioral of sequencer is
    signal cycle_count : integer range 0 to 4 := 0;  
begin
    process(clk, reset)
    begin
        if reset = '1' then
 			RnW <= '1';
                    	selA <= '0';
                    	selB <= '0';
                   	pc_ld <= '0';
                   	ir_ld <= '1';
                   	acc_ld <= '0';
                   	acc_oe <= '0';
                    	alufs <= "11";

        elsif rising_edge(clk) then
            case cycle_count is

                -- >>> CYCLE 1 <<<
                when 0 =>
                    RnW <= '1';
                    selA <= '0';
                    selB <= '0';
                    pc_ld <= '0';
                    ir_ld <= '1';
                    acc_ld <= '0';
                    acc_oe <= '0';
                    alufs <= "11";
                    cycle_count <= 1;

                -- >>> CYCLE 2 <<<
                when 1 =>
                    RnW <= '1';
                    selA <= '0';
                    selB <= '0';
                    pc_ld <= '1';
                    ir_ld <= '0';
                    acc_ld <= '0';
                    acc_oe <= '0';
                    alufs <= "11";
                    cycle_count <= 2;



                when 2 =>
                    RnW <= '1';
                    selA <= '1';
                    selB <= '1';
                    pc_ld <= '0';
                    ir_ld <= '0';
                    acc_ld <= '1';
                    acc_oe <= '0';
                    alufs <= "00";
                    cycle_count <= 3;

                when 3 =>
                    RnW <= '1';
                    selA <= '1';
                    selB <= '1';
                    pc_ld <= '1';
                    ir_ld <= '0';
                    acc_ld <= '1';
                    acc_oe <= '0';
                    alufs <= "00";
                    cycle_count <= 4;


                when 4 =>
                    RnW <= '1';
                    selA <= '0';
                    selB <= '0';
                    pc_ld <= '0';
                    ir_ld <= '1';
                    acc_ld <= '0';
                    acc_oe <= '0';
                    alufs <= "11";
                    cycle_count <= 5;


            end case;
        end if;
    end process;
end Behavioral;


---------------------------------------------------------------end sequencer

---------------------------------------------------------------processor completed
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity Microprocessor is
    Port (
        clk       : in  STD_LOGIC;
        reset     : in  STD_LOGIC
    );
end entity Microprocessor;

architecture Behavioral of Microprocessor is



	component sequencer is
    	Port (
        	clk 	: in  STD_LOGIC;
            reset   : in  STD_LOGIC;
        	opcode  : in  STD_LOGIC_VECTOR(3 downto 0);
        	acc_Z	: in  STD_LOGIC;
        	acc_15   : in  STD_LOGIC;
        	selA	: out STD_LOGIC;
        	selB	: out STD_LOGIC;
        	RnW     : out STD_LOGIC;
        	pc_ld   : out STD_LOGIC;
        	ir_ld   : out STD_LOGIC;
        	acc_ld  : out STD_LOGIC;
        	acc_oe  : out STD_LOGIC;
        	alufs   : out STD_LOGIC_VECTOR(1 downto 0)
    	);
	end component;

    component memoire port (
        RnW      : in  std_logic; 
        adresse  : in  std_logic_vector(11 downto 0);
        data_in  : in  std_logic_vector(15 downto 0); 
        data_out : out std_logic_vector(15 downto 0)
    ); end component;

    component MUXA port ( 
        selA: in STD_LOGIC; 
        PC: in STD_LOGIC_VECTOR(11 downto 0);
        ADRESSEOP: in STD_LOGIC_VECTOR(11 downto 0); 
        Aout: out STD_LOGIC_VECTOR(11 downto 0) 
    ); end component;

    component MUXB port ( 
        selB: in STD_LOGIC; 
        E0: in STD_LOGIC_VECTOR(11 downto 0);
        E1: in STD_LOGIC_VECTOR(15 downto 0); 
        Bout: out STD_LOGIC_VECTOR(15 downto 0) 
    ); end component;

    component PC port ( 
        reset   : in  STD_LOGIC;
        pc_ld: in STD_LOGIC; 
        DataIn: in STD_LOGIC_VECTOR(15 downto 0);
        PC_out: out STD_LOGIC_VECTOR(11 downto 0) 
    ); end component;

    component IR port ( 
        ir_ld: in STD_LOGIC; 
        DataIn: in STD_LOGIC_VECTOR(15 downto 0);
        opcode: out STD_LOGIC_VECTOR(3 downto 0); 
        outIR: out STD_LOGIC_VECTOR(11 downto 0) 
    ); end component;

    component ACC port ( 
        acc_ld: in STD_LOGIC; 
        DataIn: in STD_LOGIC_VECTOR(15 downto 0);
        ACC_out: out STD_LOGIC_VECTOR(15 downto 0); 
        acc_Z: out STD_LOGIC; 
        acc_15: out STD_LOGIC 
    ); end component;

    component acc_OE port ( 
        data_in: in STD_LOGIC_VECTOR(15 downto 0); 
        acc_oe: in STD_LOGIC;
        data_out: out STD_LOGIC_VECTOR(15 downto 0) 
    ); end component;

    component UAL port ( 
        A: in STD_LOGIC_VECTOR(15 downto 0); 
        B: in STD_LOGIC_VECTOR(15 downto 0);
        alufs: in STD_LOGIC_VECTOR(1 downto 0);
        reset  : in  STD_LOGIC; 
        S: out STD_LOGIC_VECTOR(15 downto 0) 
    ); end component;

    -- signals
    signal selA, selB, RnW, pc_ld, ir_ld, acc_ld, acc_oe_sig : std_logic;
    signal alufs : std_logic_vector(1 downto 0);
    signal opcode : std_logic_vector(3 downto 0);
    signal acc_Z, acc_15 : std_logic;
    signal mem_data_out, acc_out, alu_result, alu_B, oe_out : std_logic_vector(15 downto 0);
    signal PC_out, IR_out : std_logic_vector(11 downto 0);
    signal adresse : std_logic_vector(11 downto 0);





begin




    sequencer1: sequencer port map(
        clk=>clk, reset=>reset, opcode=>opcode, acc_Z=>acc_Z, acc_15=>acc_15,
        selA=>selA, selB=>selB, RnW=>RnW, pc_ld=>pc_ld, ir_ld=>ir_ld, acc_ld=>acc_ld,
        acc_oe=>acc_oe_sig, alufs=>alufs);

    Memoire1: memoire port map(
         RnW=>RnW, adresse=>adresse, data_in=>oe_out,
        data_out=>mem_data_out);

    MUXA1: MUXA port map(selA=>selA, PC=>PC_out(11 downto 0), ADRESSEOP=>IR_out, Aout=>adresse);

    MUXB1: MUXB port map(selB=>selB, E0=>IR_out, E1=>mem_data_out, Bout=>alu_B);

    PC1: PC port map(reset=>reset, pc_ld=>pc_ld, DataIn => alu_result , PC_out=>PC_out);

    IR1: IR port map( ir_ld=>ir_ld, DataIn=>mem_data_out, opcode=>opcode, outIR=>IR_out);

    ACC1: ACC port map( acc_ld=>acc_ld, DataIn=>alu_result,
                     ACC_out=>acc_out, acc_Z=>acc_Z, acc_15=>acc_15);

    acc_OE1 : acc_OE port map(data_in=>acc_out, acc_oe=>acc_oe_sig, data_out=>oe_out);

    UAL1: UAL port map(A=>acc_out, B=>alu_B, alufs=>alufs,reset=>reset, S=>alu_result);

end Behavioral;
---------------------------------------------------------------end processor


---------------------------------------------------------------start memoire
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity memoire is
  Port (
    RnW      : in  std_logic; 
    adresse  : in  std_logic_vector(11 downto 0);
    data_in  : in  std_logic_vector(15 downto 0); 
    data_out : out std_logic_vector(15 downto 0)
  );
end memoire;

architecture Behavioral of memoire is
    type ram_type is array (0 to 4095) of std_logic_vector(15 downto 0);
    signal addr_index : integer range 0 to 4095;
    signal RAM : ram_type := ( 
    -- Program
    0  => x"0010",  -- LDA @A   
    1  => x"3011",  -- SUB @B   
    2  => x"5004",  -- JGE @4   
    3  => x"7000",  -- STP      
    4  => x"1010",  -- STO @A   
    5  => x"0014",  -- LDA @C   
    6  => x"2013",  -- ADD @ONE 
    7  => x"1014",  -- STO @C   
    8  => x"4000",  -- JMP @0   

    -- Data
    16 => x"0005",  -- A initial value = 5
    17 => x"0003",  -- B value = 3
    19 => x"0001",  -- ONE = 1 (constant)
    20 => x"0000",  -- C initial value = 0

    others => (others => '0')
  );
  begin
    addr_index <= to_integer(unsigned(adresse));
	process(RnW, addr_index, data_in)
	begin
    	if RnW = '0' then
        	-- Écriture : utilisation de addr_index
        	RAM(addr_index) <= data_in;
   	     --data_out <= (others => 'Z');
    	else
        	data_out <= RAM(addr_index);
    	end if;
	end process;

end Behavioral;
---------------------------------------------------------------end memoire

---------------------------------------------------------------start PC
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity PC is
    Port (
        reset   : in  STD_LOGIC;
        pc_ld   : in  STD_LOGIC;
        DataIn  : in  STD_LOGIC_VECTOR(15 downto 0);
        PC_out  : out STD_LOGIC_VECTOR(11 downto 0)
    );
end PC;

architecture pc1 of PC is
    signal PC_reg : STD_LOGIC_VECTOR(11 downto 0) := (others => '0');
begin
    process(reset, pc_ld, DataIn)
    begin
        if reset = '1' then
            PC_reg <= (others => '0');              -- initialize PC to 0
        elsif pc_ld = '1' then
            PC_reg <= DataIn(11 downto 0);          -- load new address
        end if;
    end process;

    PC_out <= PC_reg;
end pc1;
---------------------------------------------------------------end PC


---------------------------------------------------------------start OE
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity acc_OE is
	Port (
    	data_in  : in  STD_LOGIC_VECTOR(15 downto 0);    	
    	acc_oe   : in  STD_LOGIC;                 	
    	data_out : out STD_LOGIC_VECTOR(15 downto 0) 
	);
end acc_OE;

architecture Behavioral of acc_OE is
begin
	process(data_in, acc_oe)
	begin
    	if acc_oe = '1' then
        	data_out <= data_in;
    	else
        	data_out <= (others => 'Z'); 
  	end if;
	end process;
end Behavioral;

---------------------------------------------------------------end OE

---------------------------------------------------------------start ACC

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity ACC is
    Port (
    	acc_ld   : in  STD_LOGIC;
    	DataIn   : in  STD_LOGIC_VECTOR(15 downto 0);
    	ACC_out  : out STD_LOGIC_VECTOR(15 downto 0);
    	acc_Z     : out STD_LOGIC;
    	acc_15    : out STD_LOGIC   
    );
end ACC;

architecture Behavioral of ACC is
	signal ACC_reg : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
begin
	process(acc_ld, DataIn)
	begin
    	if acc_ld = '1' then
        	ACC_reg <= DataIn;
    	end if;
	end process;
 
	ACC_out <= ACC_reg;
	acc_Z    <= '1' when ACC_reg = x"0000" else '0';
	acc_15 <= ACC_reg(15);
end Behavioral;

---------------------------------------------------------------end ACC

---------------------------------------------------------------start IR
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity IR is
    Port (
    	ir_ld   : in  STD_LOGIC;                    	
    	DataIn  : in  STD_LOGIC_VECTOR(15 downto 0);	
    	opcode  : out STD_LOGIC_VECTOR(3 downto 0); 	
    	outIR   : out STD_LOGIC_VECTOR(11 downto 0) 
    );
end IR;

architecture Behavioral of IR is
	signal IR_reg : STD_LOGIC_VECTOR(15 downto 0) := (others => '0');
begin
	process(ir_ld, DataIn)
	begin
    	if ir_ld = '1' then
        	IR_reg <= DataIn;
    	end if;
	end process;
 
	opcode <= IR_reg(15 downto 12);
	outIR  <= IR_reg(11 downto 0);

end Behavioral;


---------------------------------------------------------------end IR

---------------------------------------------------------------start UAL
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity UAL is
    Port (
        A      : in  STD_LOGIC_VECTOR(15 downto 0);
        B      : in  STD_LOGIC_VECTOR(15 downto 0);
        alufs  : in  STD_LOGIC_VECTOR(1 downto 0);
        reset  : in  STD_LOGIC;
        S      : out STD_LOGIC_VECTOR(15 downto 0)
    );
end UAL;

architecture Behavioral of UAL is
    signal A_int, B_int : STD_LOGIC_VECTOR(15 downto 0);
begin
    -- when reset=1, force A and B to zero
    A_int <= (others => '0') when reset = '1' else A;
    B_int <= (others => '0') when reset = '1' else B;

    process(A_int, B_int, alufs)
    begin
        case alufs is
            when "00" => S <= B_int;
            when "01" => S <= std_logic_vector(unsigned(A_int) - unsigned(B_int));
            when "10" => S <= std_logic_vector(unsigned(A_int) + unsigned(B_int));
            when "11" => S <= std_logic_vector(unsigned(B_int) + 1);
            when others => S <= (others => '0');
        end case;
    end process;
end Behavioral;
---------------------------------------------------------------end UAL


---------------------------------------------------------------start MUXA
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity MUXA is
    Port (
    	selA  	: in  STD_LOGIC;                	
    	PC    	: in  STD_LOGIC_VECTOR(11 downto 0);
    	ADRESSEOP : in  STD_LOGIC_VECTOR(11 downto 0);
    	Aout  	: out STD_LOGIC_VECTOR(11 downto 0) 
    );
end MUXA;

architecture Behavioral of MUXA is
begin
	Aout <= PC    	when selA = '0' else
        	ADRESSEOP when selA = '1' else
        	(others => '0');
end Behavioral;

---------------------------------------------------------------end MUXA

---------------------------------------------------------------start MUXB
library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity MUXB is 
    Port ( 
        selB: in STD_LOGIC; 
        E0: in STD_LOGIC_VECTOR(11 downto 0);
        E1: in STD_LOGIC_VECTOR(15 downto 0); 
        Bout: out STD_LOGIC_VECTOR(15 downto 0) 
    ); 
end MUXB;

architecture muxB of MUXB is 
begin 
    Bout <= "0000" & E0 when selB = '0' else 
            E1 when selB = '1' else 
            (others => '0'); 
end muxB;

---------------------------------------------------------------end MUXB 
